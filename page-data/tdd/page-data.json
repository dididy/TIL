{"componentChunkName":"component---src-templates-wiki-post-jsx","path":"/tdd","result":{"data":{"markdownRemark":{"html":"<h1>TDD</h1>\n<h3>Test 종류</h3>\n<blockquote>\n<p>e2e 테스트</p>\n<p>통합 test</p>\n<p>unit test</p>\n<p>생각해봐야 할 것</p>\n</blockquote>\n<ul>\n<li>이걸 검증해서 무엇을 얻는가?</li>\n<li>\n<p>극단적인 테스트도 좋지만 투자 대비 효율을 생각해야 함</p>\n<ul>\n<li>어느수준으로 해야 내가 이 프로그램을 믿을 수 있는가?</li>\n</ul>\n</li>\n<li>기능목록(Behavior)을 만들어서 개발</li>\n<li>사용법을 우선으로 하는 테스트 작성</li>\n<li>\n<p>테스트가 외부에 의존하면 안됨</p>\n<ul>\n<li>데이터를 요청하고 받아오는건 프론트에서 테스트하지 않음</li>\n<li>외부 URL을 사용할 경우 서버가 깨지면 테스트도 다 깨짐</li>\n</ul>\n</li>\n</ul>\n<h2>Test 작성</h2>\n<blockquote>\n<p>어떻게?</p>\n</blockquote>\n<ul>\n<li>구현 전에 이런 요청을 하면 이런 결과가 나왔으면 하는 소망을 코드로 작성</li>\n<li>작업을 하나씩 나눠서 각 작업이 잘 이뤄지는지를 확인</li>\n</ul>\n<ol>\n<li>내 코드를 읽는 사람이 꼼꼼하지 않아도 이해하기 쉽게 작성이 된 것인가? 또는 관례를 따르고 있는 걸까?</li>\n<li>내가 다른 경우를 추가하고 싶을 때 손쉬울까? 또는 뭔가를 추가하고 싶다는 생각이 들 정도로 간단한가?</li>\n</ol>\n<blockquote>\n<p>컴포넌트 테스트</p>\n</blockquote>\n<ul>\n<li>특정 props 에 따라 컴포넌트가 크래쉬 없이 잘 렌더링이 되는지 확인</li>\n<li>이전에 렌더링했던 결과와, 지금 렌더링한 결과가 일치하는지 확인</li>\n<li>특정 DOM 이벤트를 시뮬레이트 하여, 원하는 변화가 제대로 발생하는지 확인</li>\n<li>\n<p>렌더링된 결과물을 <em>이미지</em> 로 저장을 하여 픽셀을 하나하나 확인해서 모두 일치하는지 확인</p>\n<ul>\n<li>이 경우 스토리북 사용</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/ahastudio/til/blob/master/blog/2018/12-08-given-when-then.md\">BDD Style</a></p>\n</blockquote>\n<ul>\n<li>Expected - 스펙, 기능, 작동, 행위 결정</li>\n<li>테스트를 위한 테스트를 만드는 것을 방지할 수 있음</li>\n<li>사용자의 실제 사용하는 관점에서 실제 경험 위주로 테스트</li>\n<li>\n<p>Red-Green-Refactoring</p>\n<ul>\n<li>Red 실패하는 작은 테스트를 작성(최초에는 컴파일 조차 되지 않음)</li>\n<li>Green - 빨리 테스트가 통과하게 끔 수정(이를 위해선 어떠한 죄악도 용서됨)</li>\n<li>Refactoring - 모든 중복을 제거(2번에서 수행한 죄악들을 청산)</li>\n</ul>\n</li>\n<li>\n<p>BDD Patern</p>\n<ul>\n<li>\n<p>describe-context-it</p>\n<ul>\n<li>describe :  설명할 텍스트 대상을 명시하는 것(여러개의 테스트 함수를 묶어줌)</li>\n<li>context : 대상이 놓인 상황을 설명</li>\n<li>\n<p>it : 테스트 대상의 행동을 설명</p>\n<ul>\n<li>arrange, assert, act</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://martinfowler.com/bliki/GivenWhenThen.html\">given-when-then</a></p>\n<ul>\n<li>given : 테스트 전의 상태(이런 상황에서)</li>\n<li>when : 테스트의 행위(이렇게 하면)</li>\n<li>then : 검증에 해당(어떻게 되나)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>React Testing Library - <a href=\"https://www.daleseo.com/react-testing-library/\">example1</a> / <a href=\"https://velog.io/@velopert/tdd-with-react-testing-library\">example2</a></h2>\n<blockquote>\n<p><a href=\"https://testing-library.com/docs/react-testing-library/setup\">Setup</a></p>\n</blockquote>\n\n        <deckgo-highlight-code language=\"bash\"  terminal=\"carbon\" >\n          <code slot=\"code\"># install\nnpm i -D jest babel-jest @types/jest @testing-library/react @testing-library/jest-dom\n\n# execute\nnpx jest --watchAll --coverage</code>\n        </deckgo-highlight-code>\n      \n<ul>\n<li><code>.eslintrc.js</code>의 <code>env</code> 객체에 <code>jest: true</code> 추가해야 jest에 대한 린트 옵션 동작</li>\n<li><code>jest.config.js</code>를 만들어서 테스트할 때 마다 필요한 <code>import '@testing-library/jest-dom';</code>을 안써줘도 됨</li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.logrocket.com/enzyme-vs-react-testing-library-a-mindset-shift/\">Enzyme vs React Testing Library</a></p>\n</blockquote>\n<ul>\n<li>\n<p>Enzyme은 Implementation Driven Test 방법론을 따르는 테스트 작성에 용이</p>\n<ul>\n<li>실제 DOM이 아닌 React의 가상 DOM 기준으로 테스트 작성</li>\n<li>테스트 대상 React 컴포넌트에 어떤 prop이 넘어가고, 현재 state가 어떻게 되는지 검증 용이</li>\n</ul>\n</li>\n<li>\n<p>React Testing Library는 Behavior Driven Test 방법론을 따르는 테스트 작성에 용이</p>\n<ul>\n<li>jsdom이라는 라이브러리를 이용해 실제 브라우저 DOM 기준으로 테스트 작성</li>\n<li>어떤 React 컴포넌트를 사용하는지는 의미가 없고 사용자 브라우저에서 렌더링하는 실제 HTML마크업의 모습에 대한 테스트 용이</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://testing-library.com/docs/react-testing-library/api\">API</a></p>\n</blockquote>\n<ul>\n<li>\n<p>fireEvent</p>\n<ul>\n<li>쿼리 함수로 선택된 영역을 대상으로로 특정 이벤트를 발생시키기 위한 이벤트 함수들을 담고 있음</li>\n<li><code>fireEvent.click(getByXxx)</code></li>\n<li><code>fireEvent.change(email, { target: { value: \"user@test.com\" } })</code></li>\n</ul>\n</li>\n<li>\n<p>render</p>\n<ul>\n<li>인자로 렌더링할 React 컴포넌트를 넘겨 라이브러리가 제공하는 모든 쿼리 함수와 기타 유틸리티 함수를 담고있는 객체를 리턴함</li>\n</ul>\n</li>\n<li>\n<p>cleanup</p>\n<ul>\n<li>Unmounts the component from the container and destroys the container.</li>\n</ul>\n</li>\n<li>\n<p>act</p>\n<ul>\n<li>All renders and events being fired are wrapped in <code>act</code>.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://testing-library.com/docs/react-testing-library/cheatsheet\">Queries</a></p>\n</blockquote>\n<ul>\n<li>container : component가 마운트 된 DOM node에 대한 참조</li>\n<li>\n<p>getByXxx() : render API에서 꺼내 씀</p>\n<ul>\n<li>getByText : 정규식도 인자로 받을 수 있음</li>\n<li>getByAltText : <code>&#x3C;img/></code> 태그는 내부에 텍스트가 없기 때문에, 대신 alt 속성값을 이용</li>\n<li>getByLabelText : <code>&#x3C;label /></code> 태그의 내용을 가져옴, label 태그는 htmlFor로 input의 id를 통해 연결함</li>\n<li>getByPlaceholderText</li>\n<li>getByTestId : 태그에 data-testid 값을 설정하면 해당 태그의 존재 유무를 확인</li>\n<li>뒤에 <code>.value</code>를 붙이면 값을 얻을 수 있음 이 경우 <code>.toBe()</code> 매쳐와 조합하여 값 확인 가능</li>\n</ul>\n</li>\n<li>\n<p>queryByXxx()</p>\n<ul>\n<li>queryByText</li>\n</ul>\n</li>\n<li>findByXxx()</li>\n</ul>\n<blockquote>\n<p><a href=\"https://medium.com/@sgpropguide/react-testing-library-and-jest-testing-for-href-tag-6ecb7dfc018a\">Get from query selector and attribute</a></p>\n</blockquote>\n<ul>\n<li><code>document.querySelector(\"something\").getAttribute(\"something\")</code></li>\n</ul>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">it(&quot;Component renders link to /somewhere&quot;, () =&gt; {\n  const { getByText } = render(&lt;Component something=&quot;something&quot; /&gt;)\n  expect(document.querySelector(&quot;a&quot;).getAttribute(&quot;href&quot;)).toBe(&quot;/somewhere&quot;)\n})</code>\n        </deckgo-highlight-code>\n      \n<h2>Jest</h2>\n<blockquote>\n<p><a href=\"https://jestjs.io/docs/en/mock-functions\">Mock Functions</a></p>\n</blockquote>\n<ul>\n<li>\n<p>jest.fn()</p>\n<ul>\n<li>단위 테스트를 작성할 때, 해당 코드가 의존하는 부분을 가짜로 대체하는 기법</li>\n<li>가짜 함수는 자신이 어떻게 호출되었는지를 모두 기억함</li>\n<li>mockReturnValue : 가짜 함수가 어떤 값을 리턴해야할지 설정</li>\n<li>mockResolvedValue : 가짜 비동기 함수를 만들 수 있음</li>\n<li>mockImplementation : 해당 함수를 통째로 재구현할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>jest.spyOn()</p>\n<ul>\n<li>어떤 객체에 속한 함수의 구현을 가짜로 대체하지 않고, 해당 함수의 호출 여부와 어떻게 호출되었는지만을 알아내야 할 경우</li>\n</ul>\n</li>\n<li>\n<p>jest.mock()</p>\n<ul>\n<li>매개변수와 같은 이름이 있는지 파일을 뒤져서 가져다 씀</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"https://jestjs.io/docs/en/using-matchers\">Using Matchers</a></p>\n</blockquote>\n<ul>\n<li>expect에 붙여서 사용함</li>\n<li>\n<p><code>mocking</code></p>\n<ul>\n<li>toBeCalled</li>\n<li>toBeCalledTimes : 몇번 호출되었는가</li>\n<li>toBeCalledWith : 인자로 무엇이 넘어왔는가</li>\n</ul>\n</li>\n<li>\n<p><code>true/false</code></p>\n<ul>\n<li>toBeFalthy : 검증 대상이 False인지 검증</li>\n<li>toBeTruthy : 검증 대상이 True인지 검증</li>\n</ul>\n</li>\n<li>\n<p><code>array</code></p>\n<ul>\n<li>toContain : 배열에 특정 원소가 들어있는지 체크</li>\n<li>toContainEqual : 객체가 같은지 체크?</li>\n<li>toHaveLength : 배열의 길이 체크</li>\n</ul>\n</li>\n<li>\n<p><code>enabled/disabled</code></p>\n<ul>\n<li>toBeEnabled : 활성화 되었는지 검증</li>\n<li>toBeDisabled : 비활성화 되었는지 검증</li>\n</ul>\n</li>\n<li>\n<p><code>string</code></p>\n<ul>\n<li>toBe : 문자열이 정확하게 일치하는가?</li>\n<li>toMatch : 정규식 기반의 문자열 텍스트</li>\n</ul>\n</li>\n<li>toBeInTheDocument : 화면에 존재하는지 검증</li>\n<li>toBeNull</li>\n<li>toEqual</li>\n<li>toHaveAttribute : <code>toHaveAttribute(\"src\", \"https://something\")</code></li>\n<li>toHaveProperty</li>\n<li>toHaveStyle : 해당 DOM 에 특정 스타일이 있는지 쉽게 확인</li>\n<li>toHaveTextContent : container 엘리먼트 속의 텍스트가 예상과 일치하는지 검증</li>\n<li>toThrow : 예외 발생 여부 테스트 인자로 문자열을 넘기면 예외메시지, 정규식을 넘기면 정규식 체크</li>\n</ul>\n<blockquote>\n<p><a href=\"https://jestjs.io/docs/en/setup-teardown\">Setup and teardown</a></p>\n</blockquote>\n<ul>\n<li>\n<p>반복작업</p>\n<ul>\n<li>\n<p>beforeEach : 테스트 함수가 실행되기 전에 매번 실행</p>\n<ul>\n<li>\n<p>dispatch가 하나인데 우연찮게 여러번 호출되는 경우</p>\n<ul>\n<li>beforeEach에 dispatch.mockClear()를 해줘야 함</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>afterEach : 테스트 함수가 실행된 후에 매번 실행</li>\n</ul>\n</li>\n<li>\n<p>오직 한번만</p>\n<ul>\n<li>beforeAll : 맨 처음에 한번 실행</li>\n<li>after All : 맨 끝에 한번 실행</li>\n</ul>\n</li>\n<li>only : 테스트 실행시 only만 실행</li>\n<li>skip : 테스트 실행시 skip은 실행 안함</li>\n</ul>\n<blockquote>\n<p>.mock</p>\n</blockquote>\n<ul>\n<li>jest.mock('react-redux')가 <code>__mocks__</code> 폴더의 react-redux의 것을 가져옴</li>\n<li>\n<p>그렇다면 .mock은 무엇인가?</p>\n<ul>\n<li>외부 모듈을 모킹할 수 있음</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>fixtures</p>\n</blockquote>\n<ul>\n<li>테스트에 넣을 고정된 값</li>\n<li>src 상위 폴더에 만들어서 넣음</li>\n</ul>","frontmatter":{"path":"/tdd","title":"TDD"}}},"pageContext":{}}}