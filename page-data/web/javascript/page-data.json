{"componentChunkName":"component---src-templates-wiki-post-jsx","path":"/web/javascript","result":{"data":{"markdownRemark":{"html":"<h1>Javascript</h1>\n<h3>WebRTC</h3>\n<ul>\n<li><a href=\"https://github.com/im-d-team/Dev-Docs/blob/20200927/Javascript/WebRTC.md\">im-d-team: WebRTC에 대해 발표</a></li>\n</ul>\n<h3>논리연산자</h3>\n<ul>\n<li><a href=\"https://github.com/im-d-team/Dev-Docs/blob/20200830/dididy/Javascript/%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EC%9E%90.md\">im-d-team: JavaScript 논리연산자에 대해 발표</a></li>\n</ul>\n<h3>prototype</h3>\n<ul>\n<li><a href=\"https://github.com/im-d-team/Dev-Docs/blob/20200803/dididy/Javascript/prototype(2).md\">im-d-team: JavsScript Prototype에 대해 발표</a></li>\n</ul>\n<h3>this</h3>\n<ul>\n<li><a href=\"https://docs.google.com/presentation/d/1FJx2acuRHSjQ_9app2IdNt3jVuhAgppq2AqZpDCFqjo/edit?usp=sharing\">im-d-team: JavsScript this에 대해 발표</a></li>\n</ul>\n<h3>window</h3>\n<blockquote>\n<p>window.open(<url>)</p>\n</blockquote>\n<ul>\n<li><code>const newWindow = window.open(&#x3C;url>);</code> 형태로 사용하면 <code>newWindow</code> 객체로 새로 띄운 창에대한 조작이 가능</li>\n<li>두번째 인자로 <code>\"new\"</code>를 주면 새창에서 url 페이지를 보여줌</li>\n</ul>\n<blockquote>\n<p>onload()</p>\n</blockquote>\n<ul>\n<li><code>newWindow.onload = function something () {};</code> 형태로 사용하면 해당 객체가 포함된 창의 로딩이 끝난 뒤에 함수 실행 가능</li>\n</ul>\n<blockquote>\n<p>window.location</p>\n</blockquote>\n<p>window.location : 현재 어디에 있는지 확인 가능</p>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">const { location: { pathname } } = window;</code>\n        </deckgo-highlight-code>\n      \n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">const MyComponent = {\n  &#39;/&#39;: HomePage,\n  &#39;/restaurants&#39;: RestaurantsPage,\n}[pathname] || NotFoundPage;</code>\n        </deckgo-highlight-code>\n      \n<h3>Modern Javascript</h3>\n<blockquote>\n<p>let, const</p>\n</blockquote>\n<ul>\n<li>let을 하면 변수 영역이 코드 블록 안으로 한정됨</li>\n</ul>\n<blockquote>\n<p>구조분해할당</p>\n</blockquote>\n<ul>\n<li>배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 푤현식</li>\n</ul>\n<blockquote>\n<p>rest parameter</p>\n</blockquote>\n<ul>\n<li>\n<p>먼저 선언된 parameter에 할당된 argument를 제외한 나머지 argument들이 모두 배열에 담겨 할당</p>\n<ul>\n<li>따라서 마지막 파라미터여야 함</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>spread operator</p>\n</blockquote>\n<ul>\n<li>배열, 문자열 등의 이터러블을 분해해서 개별요소로 만들 수 있음</li>\n</ul>\n<blockquote>\n<p>arrow function</p>\n</blockquote>\n<ul>\n<li>익명함수</li>\n<li>더 간결하게 표현 가능</li>\n<li>매개변수 1개라면 괄호() 생략 가능</li>\n<li>중괄호와 return 문을 생략 가능</li>\n<li>this가 정적으로 묶임</li>\n</ul>\n<blockquote>\n<p>promise</p>\n</blockquote>\n<ul>\n<li>\n<p>callback</p>\n<ul>\n<li>비동기 작업은 callback queue에 쌓이고 event loop에 의해 callstack으로 이동</li>\n<li>callback의 예로는 ajax, setTimeout 등이 있음</li>\n</ul>\n</li>\n<li>자바스크립트 비동기 처리를 위한 객체</li>\n<li>\n<p>3가지 상태</p>\n<ul>\n<li>대기 : pending(new)</li>\n<li>\n<p>이행 : fulfilled(resolve-then)</p>\n<ul>\n<li>\n<p>.then 메소드는 Promise 객체에 붙여서 사용함</p>\n<ul>\n<li>Promise 객체를 리턴하고 두개의 콜백 함수를 파라미터로 받음</li>\n<li>\n<p>callback 지옥을 벗어날 수 있도록 해줌</p>\n<ul>\n<li>callback도 코딩 패턴으로 해결할 수 있기는 함</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>promise.then(successCallback, failureCallback)</li>\n</ul>\n</li>\n<li>거부 : rejected(reject-catch)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>ES8 - async/await</p>\n</blockquote>\n<ul>\n<li>비동기 처리 메서드가 꼭 프로미스 객체를 반환해야 await이 의도한 대로 동작함</li>\n<li>promise로 .then()하는건 번거로웠던 것을 편리하게 해줌</li>\n<li>try/catch로 에러처리 가능</li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/CodeSoom/week2-assignment-2/pull/15#issuecomment-643542178\">sort, splice, slice / filter, map, reduce</a></p>\n</blockquote>\n<ul>\n<li>sort, splice, slice는 기존의 배열에 영향을 줌</li>\n<li>\n<p>fliter, map, reduce는 새로운 배열을 반환</p>\n<ul>\n<li>왜 쓰는가? : 함수형 프로그래밍은 가능한 한 상태 변경을 피하고자 하며 함수 간의 데이터 흐름을 사용하기 때문에 새로운 배열을 반환하는 것</li>\n<li>\n<p>react에서 원소를 제거 할 때 state 의 배열에 직접 접근하면 안 되고, 배열을 복사한 후 원소 제거 후 기존 값에 덮어씌워져야함</p>\n<ul>\n<li>\n<p>state에 push, pop, shite 등의 원본 변형 메소드를 사용하면 안됨(immutable의 중요성) </p>\n<ul>\n<li>Vitural DOM에 영향을 주게됨</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">function deleteTodo(passedKey) {\n    setState({\n      todo:  state.todo.splice(passedKey, 1),\n    });\n}\nfunction deleteTodo(passedKey) {\n  const array = state.todo.filter((i, key) =&gt; (key !== passedKey));\n  setState({\n    todo: array,\n  });\n}</code>\n        </deckgo-highlight-code>\n      \n<hr>\n<blockquote>\n<p>etc</p>\n</blockquote>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">() =&gt; {\n\treturn {\n\t  ...\n\t}\n}\n\n() =&gt; ({\n  ...\n})</code>\n        </deckgo-highlight-code>\n      \n<p>그외에도 default parameter, template literal, generator</p>\n<h3>shallow copy를 deep copy로</h3>\n<p><code>pass by reference</code>인 경우가 얕은 복사(shallow copy)임</p>\n<blockquote>\n<p>그냥 deep copy가 되는 자료형들</p>\n</blockquote>\n<ul>\n<li><code>Boolean</code>, <code>null</code>, <code>undefined</code>, <code>string</code>, <code>Number</code> 같은 primitive 타입은 deep copy(pass by value)</li>\n</ul>\n<blockquote>\n<p>shallow copy를 deep copy로 만드는 법</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>Objects</strong>: <code>Array</code>, <code>Function</code>, <code>Object</code></p>\n<ul>\n<li>그냥 변수에 객체를 대입하면 주소(reference)가 복사됨</li>\n<li>\n<p>ES6 이후 deep copy는 Object.assign() 함수와 spread 연산자({...})를 사용</p>\n<ul>\n<li>그런데도 여전히 객체의 프로퍼티로 객체를 가지면 주소를 참조해버림</li>\n<li>lodash의 <code>_.cloneDeep</code> 을 사용하면 객체의 모든 프로퍼티를 deep copy 가능</li>\n<li>\n<p>간단하게는 <code>let copy = JSON.parse(JSON.stringify(original));</code> 사용</p>\n<ul>\n<li>하지만 string으로 바꿨다가 다시 parse하는 방식은, object내에 function이 value로 있을 경우 적합하지 않음</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>shallow comparison</p>\n</blockquote>\n<ul>\n<li>\n<p>React에서 성능을 위해 사용</p>\n<ul>\n<li>state변경, 부모컴포넌트 렌더링 &#x3C;- 얕은비교로 새로운 값인지 아닌지 판단</li>\n</ul>\n</li>\n<li>\n<p><strong>하지만 상태값이 객체라면 주의</strong> *</p>\n<ul>\n<li>객체는 기본적으로 shallow copy를 하므로 주소를 참조함</li>\n<li>\n<p>shallow comparison에서 참조 타입은 동일 참조 값이 아니라면 <code>===</code> Strict Equal Operator에서 false를 반환</p>\n<ul>\n<li>객체나 배열, 함수 등의 props는 상황에 따라 <strong>불필요한 리렌더링이 발생할 수 있음</strong> 혹은 참조값이 같다면 <strong>렌더링이 발생하지 않을 수 있음</strong></li>\n</ul>\n</li>\n<li>deep comparison을 하는 방법 : <a href=\"https://codingbroker.tistory.com/109\">https://codingbroker.tistory.com/109</a></li>\n</ul>\n</li>\n<li>\n<p>불변성을 보장하기 위해(shallow comparison이 쓸데없이 발생하는 것을 방지하기 위해)</p>\n<ul>\n<li>class 컴포넌트의 경우 <code>shouldComponentUpdate</code> 사용</li>\n<li>\n<p>함수형(hooks) 컴포넌트의 경우 <code>React.memo()</code> 사용</p>\n<ul>\n<li>첫번짜 인자 : 컴포넌트에 적용하여 props의 얕은 비교를 하여 render의 실행여부를 결정</li>\n<li>두 번째 인자 : 현재 Props와 미래의 Props를 비교하여 <code>shouldComponentUpdate</code> 처럼 렌더링을 직접 제어</li>\n<li>\n<p>useMemo, useCallback으로 값과 함수에 대한 메모이제이션 가능</p>\n<ul>\n<li>첫 번째 인자 : ~</li>\n<li>두 번째 인자 : 변경 여부를 평가하는 값들의 배열</li>\n<li>만일 불변성이 보장되지 않은 값들이나 children과 같은 ReactElement를 받아와서 사용한다면 **최적화가 의미가 없는 결과가 됨</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Object.assign과 srpead</p>\n</blockquote>\n<ul>\n<li>\n<p>Object.assgin</p>\n<ul>\n<li>소스 객체의 프로퍼티들을 타겟 객체로 복사하여 반환</li>\n<li>\n<p>파라미터로는 저장될 타켓 객체, 소스가될 객체</p>\n<ul>\n<li>\n<p>소스가 될 객체는 여러개가 되어도 되지만 deep merge가 아닌 shallow merge</p>\n<ul>\n<li>\n<p>일치하는 key가 있으면 해당 key의 value만 바뀜</p>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">const A1 = {\n  B: {\n    C: &#39;A1.B.C&#39;\n  }\n};\n\nconst A2 = {\n  B: {\n    D: &#39;A2.B.D&#39;\n  }\n};\n\nconsole.log(Object.assign(A1, A2));\n/* 실제 결과\n{\n  B: {\n    D: &#39;A2.B.D&#39;\n  }\n}\n*/\n/* 의도했던 결과\n{\n  B: {\n    C: &#39;A1.B.C&#39;,\n    D: &#39;A2.B.D&#39;\n  }\n}\n*/\n// spread를 사용해도 같은 결과가 나옴\n// 어떻게 해결할까? \n// 1. loadash merge 사용\n// 2. npm 라이브러리인 deepmerge 사용\n// 3. https://gist.github.com/ahtcx/0cd94e62691f539160b32ecda18af3d6\n// ref : https://blog.ull.im/engineering/2019/04/01/javascript-object-deep-copy.html</code>\n        </deckgo-highlight-code>\n      \n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>\n<p>spread</p>\n<ul>\n<li>Object.assign과 동일한 효과</li>\n<li>객체 앞에 ...을 붙여주면 됨</li>\n<li>배열에서도 사용 가능</li>\n</ul>\n</li>\n<li>\n<p>공통점</p>\n<ul>\n<li>동일한 기능을 함</li>\n<li>shallow copy가 됨</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>shallow copy와 참조의 차이</p>\n</blockquote>\n<ul>\n<li>참조는 <code>const ref = obj;</code> 같이 <code>=</code> 를 사용하여 함</li>\n<li>shallow copy는 <code>Object.assign</code> 혹은 <code>...</code> 을 사용</li>\n<li>\n<p>참조는 단순한 참조임</p>\n<ul>\n<li>메모리 힙에 생성된 객체를 단순히 참조하는 것</li>\n</ul>\n</li>\n<li>\n<p>shallow copy는 새로운 객체에 프로퍼티를 복사하는 것 </p>\n<ul>\n<li>여전히 해당 객체를 참조하는게 맞지만 프로퍼티가 복사된다는 차이점이 있음</li>\n</ul>\n</li>\n</ul>\n<h3>Axios vs Fetch</h3>\n<blockquote>\n<p>Axios</p>\n</blockquote>\n<ul>\n<li>Promise based</li>\n</ul>\n<blockquote>\n<p>Fetch</p>\n</blockquote>\n<ul>\n<li>Promise based</li>\n<li>Request Aborting에 대해서 표준적인 방법을 제공 못함</li>\n<li>response timeout API is not exist</li>\n<li>Some browser is not support</li>\n<li>\n<p>Error handling</p>\n<ul>\n<li>Catch에 걸렸을 때 .then(~)을 실행</li>\n<li>Axios의 경우는 .tehn(~) 실행하지 않고, console창에 해당 에러로그 보여줌</li>\n</ul>\n</li>\n</ul>\n<h3>Convention</h3>\n<ul>\n<li>error first</li>\n</ul>\n<h3>Babel</h3>\n<ul>\n<li>Javascript 엔진은 브라우저마다 다르고 ES6 조차 지원하지 않는 브라우들이 있기 때문에 그러한 구형 브라우저에서 돌아갈 수 있도록 코드 자체를 변환함</li>\n</ul>","frontmatter":{"path":"/web/javascript","title":"Javascript"}}},"pageContext":{}}}