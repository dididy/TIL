{"componentChunkName":"component---src-templates-wiki-post-jsx","path":"/web/react","result":{"data":{"markdownRemark":{"html":"<h1>React</h1>\n<p>관심사의 분리(SoC : Separation of concerns)</p>\n<blockquote>\n<p>react가 dom보다 빠른게 아님</p>\n</blockquote>\n<ul>\n<li>유지보수가 되는 웹을 만드는것을 도와줌</li>\n<li>\n<p>react는 성능 최적화를 도와줌</p>\n<ul>\n<li>reconciliation(재조정)을 잘 고려해야 함</li>\n<li>데이터의 분별성</li>\n</ul>\n</li>\n<li>React의 props와 state 비교 로직은 얕은 비교</li>\n<li>shouldComponentUpdate 작성, 혹은  PureComponent 활용</li>\n</ul>\n<h2><a href=\"https://reactjs.org/docs/dom-elements.html\">Dom element</a></h2>\n<p>HTML과 다르게 작동하는 Attribute</p>\n<blockquote>\n<p>onChange</p>\n</blockquote>\n<ul>\n<li>form field가 변경될 때 이벤트가 발생함</li>\n<li>의도적으로 기존 브라우저의 동작을 사용하지 않음</li>\n<li>React는 기존 브라우저와 별개로 실시간으로 유저 입력을 처리하는 이벤트에 의존함</li>\n</ul>\n<blockquote>\n<p>value</p>\n</blockquote>\n<ul>\n<li><code>&#x3C;input></code>과 <code>&#x3C;textarea></code> 컴포넌트에 의해 지원됨</li>\n<li>컴포넌트의 값을 설정할 수 있음</li>\n<li>제어 컴포넌트를 만드는데 유용함</li>\n<li><code>defaultValue</code> 비제어 컴포넌트에서 사되는 동등한 의미를 가지는 Attribute</li>\n<li>처음 마운트될 때 컴포넌트의 값을 설정</li>\n</ul>\n<blockquote>\n<p>dangerouslySetInnerHTML</p>\n</blockquote>\n<ul>\n<li>브라우저 DOM에서 <code>innerHTML</code>을 사용하기 위한 방법</li>\n<li>\n<p>코드에 HTML을 설정하게 되면 XSS(cross-site-scripting) 쉽게 노출될 수 있음</p>\n<ul>\n<li>React DOM은 렌더링 되기 전에 jsx 내에 포함된 모든 값을 문자열로 바꾸기 때문에 기본적으로 XSS를 막을 수 있음</li>\n</ul>\n</li>\n<li>위험하다는걸 상기시키기 위한 Attribute이고 <code>__html</code>키로 객체를 전달해야 함</li>\n</ul>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">function createMarkup() {\n  return {__html: &#39;First &amp;middot; Second&#39;};\n}\n\nfunction MyComponent() {\n  return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;\n}</code>\n        </deckgo-highlight-code>\n      \n<hr>\n<h2><a href=\"https://reactjs.org/docs/typechecking-with-proptypes.html\">Typechecking With PropTypes</a></h2>\n<p>타입확인을 통해 bug를 잡을 수 있도록 도와줄 수 있고 Flow나 Typescript와 달리 React에 내장되어 있으므로 바로 사용 가능</p>\n<blockquote>\n<p>PropTypes</p>\n</blockquote>\n<ul>\n<li>아래와 같이 유효성 검사를 할 수 있음</li>\n</ul>\n\n        <deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" >\n          <code slot=\"code\">import PropTypes from &#39;prop-types&#39;;\n\nMyComponent.propTypes = {\n  // prop가 특정 JS 형식임을 선언할 수 있습니다.\n  // 이것들은 기본적으로 모두 선택 사항입니다.\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // 랜더링 될 수 있는 것들은 다음과 같습니다.\n  // 숫자(numbers), 문자(strings), 엘리먼트(elements), 또는 이러한 타입들(types)을 포함하고 있는 배열(array) (혹은 배열의 fragment)\n  optionalNode: PropTypes.node,\n\n  // React 엘리먼트.\n  optionalElement: PropTypes.element,\n\n  // React 엘리먼트 타입 (ie. MyComponent)\n  optionalElementType: PropTypes.elementType,\n\n  // prop가 클래스의 인스턴스임을 선언할 수 있습니다.\n  // 이 경우 JS&#39;s instanceof 연산자를 사용합니다.\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // 열거형(enum)으로 처리하여 prop가 특정 값들로 제한되도록 할 수 있습니다.\n  optionalEnum: PropTypes.oneOf([&#39;News&#39;, &#39;Photos&#39;]),\n\n  // 여러 종류중 하나의 종류가 될 수 있는 객체\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // 특정 타입의 행렬\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // 특정 타입의 프로퍼티 값들을 갖는 객체\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // 특정 형태를 갖는 객체\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n\n  // An object with warnings on extra properties\n  optionalObjectWithStrictShape: PropTypes.exact({\n    name: PropTypes.string,\n    quantity: PropTypes.number\n  }),\n\n  // 위에 있는 것 모두 `isRequired`와 연결하여 prop가 제공되지 않았을 때\n  // 경고가 보이도록 할 수 있습니다.\n  requiredFunc: PropTypes.func.isRequired,\n\n  // 모든 데이터 타입이 가능한 값\n  requiredAny: PropTypes.any.isRequired,\n\n  // 사용자 정의 유효성 검사기를 지정할 수도 있습니다.\n  // 검사 실패 시에는 에러(Error) 객체를 반환해야 합니다.\n  // `oneOfType`안에서는 작동하지 않으므로 `console.warn` 혹은 throw 하지 마세요.\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        &#39;Invalid prop `&#39; + propName + &#39;` supplied to&#39; +\n        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;\n      );\n    }\n  },\n\n  // `arrayOf` 와 `objectOf 에 사용자 정의 유효성 검사기를 적용할 수 있습니다.\n  // 검사 실패 시에는 에러(Error) 객체를 반환해야 합니다.\n  // 유효성 검사기는 배열(array) 혹은 객체의 각 키(key)에 대하여 호출될 것입니다.\n  // 유효성 검사기의 첫 두 개의 변수는 배열 혹은 객체 자신과 현재 아이템의 키입니다.\n\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        &#39;Invalid prop `&#39; + propFullName + &#39;` supplied to&#39; +\n        &#39; `&#39; + componentName + &#39;`. Validation failed.&#39;\n      );\n    }\n  })\n};</code>\n        </deckgo-highlight-code>\n      \n<blockquote>\n<p>PropTypes.elemet</p>\n</blockquote>\n<ul>\n<li>컴포넌트의 Children에 단 하나의 Child만 전달될 수 있도록 명시 가능</li>\n</ul>\n<blockquote>\n<p>defaultProps</p>\n</blockquote>\n<ul>\n<li><code>props</code>의 초기값을 정의함</li>\n</ul>\n<h2>hooks</h2>\n<p>hooks의 state 또한 immutable임</p>\n<blockquote>\n<p>useEffect</p>\n</blockquote>\n<ul>\n<li>useEffect 는 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook</li>\n<li>클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate 를 합친 형태</li>\n<li>\n<p>두번째 파라미터에 따라 달라지는 실행되는 조건</p>\n<ul>\n<li>빈 배열을 넣게되면 가장 처음 렌덜이 될 때만 실행됨</li>\n<li>배열안에 특정 갚을 넣어주면 그 값이 업데이트 때만 실행됨</li>\n</ul>\n</li>\n<li>\n<p>cleanup(뒷정리) 함수</p>\n<ul>\n<li>언마운트되기 전이나, 업데이트 되기 직전에 어떠한 작업을 수행할 때 사용</li>\n<li>useEffect 내부에서 <code>return () => {}</code></li>\n<li>뒷정리 함수가 호출 될 때에는 업데이트 되기 직전의 값을 보여줌</li>\n<li>두번째 파라미터에 빈 배열을 넣게되면 언마운트 될 때만 실행</li>\n</ul>\n</li>\n<li>\n<p>화면에 렌더링된 이후에 비동기로 처리되어야 하는 부수적인 효과들을 흔히 Side Effect라고 함</p>\n<ul>\n<li>데이터를 비동기로 가져올 경우</li>\n</ul>\n</li>\n<li>useEffect를 사용해서 리액트</li>\n</ul>\n<blockquote>\n<p>useMemo</p>\n</blockquote>\n<ul>\n<li>props를 넘겨줄 때 memoization 간편 사용 가능</li>\n<li>의존성이 변경되었을 때에만 메모이제이션 된 값만 다시 계산</li>\n</ul>\n<blockquote>\n<p>useCallback</p>\n</blockquote>\n<ul>\n<li>useMemo()의 핸들러 버전으로 메모이제이션된 함수를 가져옴 - 메모이제이션의 값이 변경되는 시점은 함수인자가 아닌 의존성 배열 형태로 받아서 판단</li>\n</ul>\n<blockquote>\n<p>useRef</p>\n</blockquote>\n<ul>\n<li>state의 값이 최신이어야 할 때 사용</li>\n<li>일종의 인스턴스</li>\n<li>내용이 변경될 때 그것을 알려주지는 않음</li>\n</ul>\n<blockquote>\n<p>useSelector</p>\n<p>useReducer</p>\n<p>useContext</p>\n</blockquote>\n<h3>퓨어 컴포넌트</h3>\n<ul>\n<li>상태를 관리하지 않는 컴포넌트와 관리하는 컴포넌트</li>\n<li>\n<p>jsx에서 virtual dom 자체를 업데이트 하는 것 조차도 싫은 경우</p>\n<ul>\n<li>virtual dom tree를 바뀌지 않게 해줌</li>\n<li>export default React.memo(); 이렇게 해주면 됨</li>\n<li>\n<p>props가 바뀔때만 재렌더링 아닌면 그냥 cache된 걸 보여줌</p>\n<ul>\n<li>커다라고 복잡한거 만들 때 사용하면 퍼포먼스에 좋음</li>\n</ul>\n</li>\n<li>Rcview,</li>\n<li>\n<p>ReviewForm,</p>\n<ul>\n<li>\n<p>handlechange, handlesubmit은 RestaurntContainer가 호출될 때 마다 매번 만들어 줌</p>\n<ul>\n<li>그래서 useCallback으로 함수 자체를 memoize 해줌</li>\n<li>useEffect 처럼 인자로 바뀌는 값만 포함 - dispatch가 바뀔 때 마다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>useMemo</p>\n<ul>\n<li>복잡한 계산</li>\n</ul>\n</li>\n<li>virtual dom은 브라우저 연산을 거치지 않고 메모리에 dom을 그림</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>React.memo()</p>\n</blockquote>\n<ul>\n<li>\n<p>사소한 변경에 모든 컴포넌트가 렌더링 하면 성능저하 발생</p>\n<ul>\n<li>class형 컴포넌트에서는 shouldComponentUpdate를 사용</li>\n<li>Pure componenet의 경우 useMemo를 사용</li>\n</ul>\n</li>\n<li>\n<p>memo는 기본적으로 shallow comparison을 수행</p>\n<ul>\n<li>원시자료형(Primitive Type)의 경우 동일한 props로 동일한 결과를 렌더링해낸다면, React.memo를 호출하고 결과를 메모이징(Memoizing)하도록 래핑하여 경우에 따라 성능 향상 </li>\n</ul>\n</li>\n<li>\n<p>경우에 따라서 deep comparison을 수행하도록 구현할 수 있음(props이 객체인 경우)</p>\n<ul>\n<li>\n<p>비교함수가</p>\n<ul>\n<li>true를 반환하면 이전의 값이 기억되어서 재렌더링을 막아주고</li>\n<li>false를 반환하면 새로운 상태로 인식하고 해당 컴포넌트를 재렌더링하게 됨</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>style</h3>\n<blockquote>\n<p>스타일 객체를 여러개 적용해야 할 경우</p>\n</blockquote>\n\n        <deckgo-highlight-code   terminal=\"carbon\" >\n          <code slot=\"code\">style={[&lt;object&gt;], [&lt;another_object&gt;]}</code>\n        </deckgo-highlight-code>\n      \n<hr>\n<h3>react-router-dom</h3>\n<p><a href=\"https://stackoverflow.com/questions/43209666/react-router-v4-cannot-get-url\">https://stackoverflow.com/questions/43209666/react-router-v4-cannot-get-url</a></p>","frontmatter":{"path":"/web/react","title":"React"}}},"pageContext":{}}}